'use strict';

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class ViewState {
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
var constants = {
    IMAGE_TYPE: 'image/jpeg',
    SUPPORTS_IMAGE_CAPTURE: 'ImageCapture' in window,
    SUPPORTS_MEDIA_DEVICES: 'mediaDevices' in navigator,
};
//# sourceMappingURL=constants.js.map

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
const DB_VERSION = 2;
class ImageDB {
    constructor() {
        const request = indexedDB.open('image-db', DB_VERSION);
        this.dbPromise = new Promise((resolve, reject) => {
            this.dbResolve = resolve;
            this.dbReject = reject;
            request.onerror = (reason) => this.dbReject(reason);
            request.onupgradeneeded = (event) => this.createObjectStore(event);
            request.onsuccess = (event) => this.dbOpened(request);
        });
    }
    /**
     * Store an image in the database. If the `id` property of the record is not
     * set, this will create a new entry. Returns the ID of the record.
     */
    store(record) {
        const promise = new Promise((resolve, reject) => {
            this.dbPromise.then((db) => {
                const transaction = db.transaction(['images'], 'readwrite');
                const put = transaction.objectStore('images').put(record);
                put.onsuccess = (event) => resolve(put.result);
                put.onerror = reject;
            }).catch(reject);
        });
        return promise;
    }
    retrieve(id) {
        const promise = new Promise((resolve, reject) => {
            this.dbPromise.then((db) => {
                const transaction = db.transaction(['images'], 'readonly');
                const get = transaction.objectStore('images').get(id);
                get.onsuccess = (event) => resolve(get.result);
                get.onerror = reject;
            }).catch(reject);
        });
        return promise;
    }
    all() {
        const promise = new Promise((resolve, reject) => {
            this.dbPromise.then((db) => {
                const transaction = db.transaction(['images'], 'readonly');
                const open = transaction.objectStore('images').openCursor();
                const results = [];
                open.onsuccess = (event) => {
                    const cursor = open.result;
                    if (cursor) {
                        results.push(cursor.value);
                        cursor.continue();
                    }
                    else {
                        resolve(results);
                    }
                };
                open.onerror = reject;
            }).catch(reject);
        });
        return promise;
    }
    dbOpened(request) {
        this.dbResolve(request.result);
        this.dbPromise.then((db) => {
            db.onerror = (reason) => this.error(reason);
        });
    }
    error(reason) {
        console.error(reason);
    }
    createObjectStore(event) {
        const request = event.target;
        const db = request.result;
        switch (event.oldVersion) {
            case 1:
                db.deleteObjectStore('images');
            case 0:
                db.createObjectStore('images', { keyPath: "id", autoIncrement: true });
        }
    }
}
var db = new ImageDB();
//# sourceMappingURL=image-db.js.map

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class View {
    constructor(viewElement) {
        this.viewElement = viewElement;
    }
    show() {
        this.viewElement.classList.remove('hidden');
    }
    hide() {
        this.viewElement.classList.add('hidden');
    }
    getState() {
        return this.state || new ViewState();
    }
    setState(state) {
        this.state = state;
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class BrowseView extends View {
    constructor() {
        super(document.getElementById('browse-view'));
        this.captureButton = document.getElementById('browse-capture-button');
        this.uploadButton = document.getElementById('browse-upload-button');
        this.emptyListElement = document.getElementById('empty-browse-list');
        this.listElement = document.getElementById('browse-list');
        if (!constants.SUPPORTS_MEDIA_DEVICES) {
            this.captureButton.classList.add('hidden');
        }
        this.captureButton.addEventListener('click', () => this.captureClick());
        this.uploadButton.addEventListener('click', () => this.uploadClick());
        this.blobURLs = new Set();
    }
    show() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            const photos = yield db.all();
            if (photos.length === 0) {
                this.emptyListElement.classList.remove('hidden');
                this.listElement.classList.add('hidden');
            }
            else {
                this.emptyListElement.classList.add('hidden');
                this.listElement.classList.remove('hidden');
                for (const record of photos) {
                    const thumb = document.createElement('div');
                    thumb.classList.add('element');
                    thumb.addEventListener('click', () => router.visit(`/edit/${record.id}`));
                    const buffer = record.thumbnail || record.edited || record.original;
                    if (buffer) {
                        const blob = new Blob([buffer], { type: constants.IMAGE_TYPE });
                        const url = URL.createObjectURL(blob);
                        const image = document.createElement('img');
                        image.src = url;
                        thumb.appendChild(image);
                        this.blobURLs.add(url);
                    }
                    else {
                        // TODO: Handle this error condition
                    }
                    this.listElement.appendChild(thumb);
                }
            }
            _super("show").call(this);
        });
    }
    hide() {
        super.hide();
        // TODO: Have a good think about this. The strategy here is to remove all
        // child elements when we hide, because smaller DOM seems like a win for the
        // rest of the app. But really we probably want a recycler instead...
        while (this.listElement.hasChildNodes()) {
            this.listElement.removeChild(this.listElement.lastChild);
        }
        for (const url of this.blobURLs) {
            URL.revokeObjectURL(url);
        }
        this.blobURLs.clear();
    }
    captureClick() {
        router.visit('/capture');
    }
    uploadClick() {
        router.visit('/upload');
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
function canvasToBlob(canvas, type) {
    return new Promise((resolve) => {
        canvas.toBlob((blob) => resolve(blob), type);
    });
}
function blobToArrayBuffer(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener('loadend', (e) => __awaiter(this, void 0, void 0, function* () {
            resolve(reader.result);
        }));
        reader.addEventListener('error', reject);
        reader.readAsArrayBuffer(blob);
    });
}
//# sourceMappingURL=promise-helpers.js.map

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
const streamConstraints = {
    audio: false,
    video: {
        deviceId: '',
        facingMode: ['user', 'environment'],
        height: { ideal: 1080 },
        width: { ideal: 1920 },
    },
};
class CameraHelper {
    constructor() {
        this.stream = null;
    }
    getCameras() {
        return __awaiter(this, void 0, void 0, function* () {
            let devices = [];
            if (constants.SUPPORTS_MEDIA_DEVICES) {
                devices = yield navigator.mediaDevices.enumerateDevices();
                devices = devices.filter((device) => device.kind === 'videoinput');
            }
            return devices;
        });
    }
    takePhoto(video) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!constants.SUPPORTS_MEDIA_DEVICES) {
                return null;
            }
            if (constants.SUPPORTS_IMAGE_CAPTURE) {
                const stream = video.srcObject;
                if (!stream) {
                    return null;
                }
                const track = stream.getVideoTracks()[0];
                const capture = new ImageCapture(track);
                return yield capture.takePhoto();
            }
            else {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                context.drawImage(video, 0, 0);
                return yield canvasToBlob(canvas, constants.IMAGE_TYPE);
            }
        });
    }
    stop() {
        this.stopStream();
    }
    stopStream() {
        if (this.stream) {
            for (const track of this.stream.getVideoTracks()) {
                track.stop();
            }
        }
    }
    startStream(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopStream();
            streamConstraints.video.deviceId = deviceId;
            const stream = yield navigator.mediaDevices.getUserMedia(streamConstraints);
            this.stream = stream;
            return stream;
        });
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class ImageRecord {
    constructor(original) {
        this.original = original;
        this.edited = null;
        this.thumbnail = null;
        this.transform = null;
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class CaptureView extends View {
    constructor() {
        super(document.getElementById('capture-view'));
        this.videoElement = this.viewElement.querySelector('video#preview');
        this.videoElement2 = this.viewElement.querySelector('video#preview2');
        this.takePhotoButton = document.getElementById('capture-button');
        this.cameraChooseButton = document.getElementById('camera-choose-button');
        this.mirrorButton = document.getElementById('capture-mirror-button');
        this.closeButton = document.getElementById('capture-view-close');
        this.videoElement2.classList.add('hidden');
        this.cameraHelper = new CameraHelper();
        this.takePhotoButton.addEventListener('click', () => this.takePhoto());
        this.cameraChooseButton.addEventListener('click', () => this.toggleCameraChooser());
        this.mirrorButton.addEventListener('click', () => this.toggleMirror());
        this.closeButton.addEventListener('click', () => this.close());
        this.devicesPromise = this.getDevices();
        this.currentDevice = null;
    }
    show() {
        this.devicesPromise.then((devices) => {
            this.currentDevice = devices[0];
            this.startStream(this.currentDevice.deviceId);
        });
        super.show();
    }
    hide() {
        this.cameraHelper.stop();
        this.videoElement.pause();
        super.hide();
    }
    getDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            const cameras = yield this.cameraHelper.getCameras();
            if (cameras.length < 2) {
                this.cameraChooseButton.classList.add('hidden');
            }
            else {
                this.cameraChooseButton.classList.remove('hidden');
            }
            return cameras;
        });
    }
    takePhoto() {
        return __awaiter(this, void 0, void 0, function* () {
            const blob = yield this.cameraHelper.takePhoto(this.videoElement);
            if (blob) {
                this.storeResult(blob);
            }
            else {
                // TODO: This is an unhandled error condition
            }
        });
    }
    toggleCameraChooser() {
        return __awaiter(this, void 0, void 0, function* () {
            // Four possible cases
            // 1. No camera! This view shouldn't even come up, we need a fallback UI
            // 2. One camera. Button should be hidden.
            // 3. Two cameras. Clicking button is a simple toggle.
            // 4. Three or more cameras. Present a chooser with the names and/or
            //    features of the cameras.
            // TODO: Need to change the button to reflect the kind of camera that will
            // be selected.
            // TODO: Need to decide what happens if we change camera while recording
            const devices = yield this.devicesPromise;
            if (devices.length < 2) {
                return;
            }
            if (this.currentDevice) {
                const currentIndex = devices.indexOf(this.currentDevice);
                // TODO: Should show chooser for many devices, not just cycle
                this.currentDevice = devices[(currentIndex + 1) % devices.length];
            }
            else {
                this.currentDevice = devices[0];
            }
            this.startStream(this.currentDevice.deviceId);
        });
    }
    close() {
        router.visit(`/browse`);
    }
    storeResult(blob) {
        return __awaiter(this, void 0, void 0, function* () {
            const buffer = yield blobToArrayBuffer(blob);
            const record = new ImageRecord(buffer);
            const id = yield db.store(record);
            router.visit(`/edit/${id}`);
        });
    }
    startStream(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = yield this.cameraHelper.startStream(deviceId);
            this.videoElement2.srcObject = stream;
            this.videoElement2.onloadedmetadata = () => {
                const temp = this.videoElement;
                this.videoElement = this.videoElement2;
                this.videoElement2 = temp;
                this.videoElement.play();
                this.videoElement.classList.remove('hidden');
                this.videoElement2.classList.add('hidden');
                this.videoElement2.pause();
            };
        });
    }
    toggleMirror() {
        this.videoElement.classList.toggle('mirror');
    }
}

var fragmentShader = "\nprecision highp float;\nvarying vec2 texCoords;\nuniform sampler2D textureSampler;\nuniform vec2 sourceSize;\nuniform float saturation;\nuniform float warmth;\nuniform float sharpen;\nuniform float brightness;\nuniform float contrast;\nuniform float blur;\nuniform float vignette;\nuniform float grey;\nvec3 saturationVector = vec3(0.299, 0.587, 0.114);\nvoid main() {\n  vec2 off = sourceSize * blur;\n  vec2 off2 = off * 2.0;\n  vec4 tex00 = texture2D(textureSampler, texCoords + vec2(-off2.x, -off2.y));\n  vec4 tex10 = texture2D(textureSampler, texCoords + vec2(-off.x, -off2.y));\n  vec4 tex20 = texture2D(textureSampler, texCoords + vec2(0.0, -off2.y));\n  vec4 tex30 = texture2D(textureSampler, texCoords + vec2(off.x, -off2.y));\n  vec4 tex40 = texture2D(textureSampler, texCoords + vec2(off2.x, -off2.y));\n  vec4 tex01 = texture2D(textureSampler, texCoords + vec2(-off2.x, -off.y));\n  vec4 tex11 = texture2D(textureSampler, texCoords + vec2(-off.x, -off.y));\n  vec4 tex21 = texture2D(textureSampler, texCoords + vec2(0.0, -off.y));\n  vec4 tex31 = texture2D(textureSampler, texCoords + vec2(off.x, -off.y));\n  vec4 tex41 = texture2D(textureSampler, texCoords + vec2(off2.x, -off.y));\n  vec4 tex02 = texture2D(textureSampler, texCoords + vec2(-off2.x, 0.0));\n  vec4 tex12 = texture2D(textureSampler, texCoords + vec2(-off.x, 0.0));\n  vec4 tex22 = texture2D(textureSampler, texCoords + vec2(0.0, 0.0));\n  vec4 tex32 = texture2D(textureSampler, texCoords + vec2(off.x, 0.0));\n  vec4 tex42 = texture2D(textureSampler, texCoords + vec2(off2.x, 0.0));\n  vec4 tex03 = texture2D(textureSampler, texCoords + vec2(-off2.x, off.y));\n  vec4 tex13 = texture2D(textureSampler, texCoords + vec2(-off.x, off.y));\n  vec4 tex23 = texture2D(textureSampler, texCoords + vec2(0.0, off.y));\n  vec4 tex33 = texture2D(textureSampler, texCoords + vec2(off.x, off.y));\n  vec4 tex43 = texture2D(textureSampler, texCoords + vec2(off2.x, off.y));\n  vec4 tex04 = texture2D(textureSampler, texCoords + vec2(-off2.x, off2.y));\n  vec4 tex14 = texture2D(textureSampler, texCoords + vec2(-off.x, off2.y));\n  vec4 tex24 = texture2D(textureSampler, texCoords + vec2(0.0, off2.y));\n  vec4 tex34 = texture2D(textureSampler, texCoords + vec2(off.x, off2.y));\n  vec4 tex44 = texture2D(textureSampler, texCoords + vec2(off2.x, off2.y));\n  vec4 tex = tex22;\n  vec4 blurred = 1.0 * tex00 + 4.0 * tex10 + 6.0 * tex20 + 4.0 * tex30 + 1.0 * tex40\n               + 4.0 * tex01 + 16.0 * tex11 + 24.0 * tex21 + 16.0 * tex31 + 4.0 * tex41\n               + 6.0 * tex02 + 24.0 * tex12 + 36.0 * tex22 + 24.0 * tex32 + 6.0 * tex42\n               + 4.0 * tex03 + 16.0 * tex13 + 24.0 * tex23 + 16.0 * tex33 + 4.0 * tex43\n               + 1.0 * tex04 + 4.0 * tex14 + 6.0 * tex24 + 4.0 * tex34 + 1.0 * tex44;\n  blurred /= 256.0;\n  tex += (tex - blurred) * sharpen;\n  vec3 desaturated = vec3(dot(saturationVector, tex.rgb));\n  vec3 mixed = mix(desaturated, tex.rgb, saturation);\n  vec4 color = vec4(mixed, tex.a);\n  color.r += warmth;\n  color.b -= warmth;\n  vec3 gray = vec3(grey, grey, grey);\n  color.rgb = mix(color.rgb * brightness, mix(gray, color.rgb, contrast), 0.5);\n  float ratio = off.x / off.y;\n  float dist = sqrt(pow(texCoords.x - 0.5, 2.0) + pow(ratio * (texCoords.y - 0.5), 2.0));\n  float vigCurve = exp(-pow(dist, 2.0) / (2.0 * pow(-vignette, 2.0)));\n  color.rgb *= vigCurve;\n  gl_FragColor = color;\n}\n";

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
const random = (min, max) => {
    let result = Math.random();
    result *= (max - min);
    result += min;
    return result;
};
class FilterTransform {
    constructor() {
        this.saturation = 1;
        this.warmth = 0;
        this.sharpen = 0;
        this.blur = 1;
        this.brightness = 1;
        this.contrast = 1;
        this.grey = 0.5;
        this.vignette = 2;
    }
    // This allows us to `for (... of ...)` over the filters
    // I really feel like there should be a simpler/clearer way to express this
    [Symbol.iterator]() {
        return function* () {
            yield ['saturation', this.saturation];
            yield ['warmth', this.warmth];
            yield ['sharpen', this.sharpen];
            yield ['blur', this.blur];
            yield ['brightness', this.brightness];
            yield ['contrast', this.contrast];
            yield ['grey', this.grey];
            yield ['vignette', this.vignette];
        }.bind(this)();
    }
    randomize() {
        this.saturation = random(0, 2);
        this.warmth = random(-0.08, 0.08);
        this.sharpen = random(-2, 2);
        this.blur = random(0.01, 4);
        this.brightness = random(0, 2);
        this.contrast = random(0, 2);
        this.grey = random(0, 1);
        this.vignette = random(0.2, 2);
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
const BASE_VERTEX_SHADER = `
attribute vec2 position;
attribute vec2 uv;

varying vec2 texCoords;

void main() {
  gl_Position = vec4(position, 0, 1.0);
  texCoords = uv;
}`;
const BASE_FRAGMENT_SHADER = `
precision highp float;

varying vec2 texCoords;

uniform sampler2D textureSampler;

void main() {
  gl_FragColor = texture2D(textureSampler, texCoords);
}`;
const POSITIONS = new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]);
const UVS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
const INDEX = new Uint16Array([0, 1, 2, 0, 2, 3]);
class ImageShader {
    constructor() {
        this.canvas = document.createElement('canvas');
        const context = this.canvas.getContext('webgl');
        if (context === null) {
            throw new Error(`Couldn't get a WebGL context`);
        }
        const gl = context;
        this.context = gl;
        const textureId = gl.createTexture();
        if (textureId === null) {
            throw new Error('Error getting texture ID');
        }
        this.textureId = textureId;
        this.programId = 0;
        this.vertShader = BASE_VERTEX_SHADER;
        this.fragShader = BASE_FRAGMENT_SHADER;
        this.uniformLocations = new Map();
        this.createVAO(INDEX, POSITIONS, UVS);
        gl.clearColor(1, 1, 1, 1);
        this.dirtyProgram = true;
    }
    setImage(image) {
        const gl = this.context;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.textureId);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        // gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }
    setVertexShader(source) {
        this.vertShader = source;
        this.dirtyProgram = true;
    }
    setFragmentShader(source) {
        this.fragShader = source;
        this.dirtyProgram = true;
    }
    setUniform(name, value) {
        const gl = this.context;
        if (this.dirtyProgram) {
            this.createProgram();
        }
        if (!this.uniformLocations.has(name)) {
            console.warn(`Tried to set unknown uniform ${name}`);
            return;
        }
        const info = this.uniformLocations.get(name);
        switch (info.type) {
            case gl.FLOAT:
                gl.uniform1fv(info.location, [value]);
                break;
            case gl.FLOAT_VEC2:
                gl.uniform2fv(info.location, value);
                break;
            case gl.FLOAT_VEC3:
                gl.uniform3fv(info.location, value);
                break;
            case gl.FLOAT_VEC4:
                gl.uniform4fv(info.location, value);
                break;
            case gl.BOOL:
            case gl.INT:
                gl.uniform1iv(info.location, [value]);
                break;
            case gl.BOOL_VEC2:
            case gl.INT_VEC2:
                gl.uniform2iv(info.location, value);
                break;
            case gl.BOOL_VEC3:
            case gl.INT_VEC3:
                gl.uniform3iv(info.location, value);
                break;
            case gl.BOOL_VEC4:
            case gl.INT_VEC4:
                gl.uniform4iv(info.location, value);
                break;
            default:
                console.error(`Couldn't set uniform, unsupported type`);
        }
    }
    render() {
        const gl = this.context;
        if (this.dirtyProgram) {
            this.createProgram();
        }
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        gl.flush();
    }
    createProgram() {
        const gl = this.context;
        const vertexShaderId = this.compileShader(this.vertShader, gl.VERTEX_SHADER);
        const fragmentShaderId = this.compileShader(this.fragShader, gl.FRAGMENT_SHADER);
        const programId = gl.createProgram();
        if (programId === null) {
            throw new Error(`Couldn't get a program ID`);
        }
        this.programId = programId;
        gl.attachShader(programId, vertexShaderId);
        gl.attachShader(programId, fragmentShaderId);
        gl.linkProgram(programId);
        if (!gl.getProgramParameter(programId, gl.LINK_STATUS)) {
            const info = gl.getProgramInfoLog(programId);
            throw new Error('Could not link shader program. \n\n' + info);
        }
        gl.validateProgram(programId);
        if (!gl.getProgramParameter(programId, gl.VALIDATE_STATUS)) {
            const info = gl.getProgramInfoLog(programId);
            throw new Error('Could not validate shader program. \n\n' + info);
        }
        gl.useProgram(programId);
        this.uniformLocations = new Map();
        this.getUniformLocations();
        this.dirtyProgram = false;
    }
    compileShader(source, type) {
        const gl = this.context;
        const shader = gl.createShader(type);
        if (shader === null) {
            throw new Error('Error creating shader');
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error(`Couldn't compiler shader: ${gl.getShaderInfoLog(shader)}`);
        }
        return shader;
    }
    getUniformLocations() {
        const gl = this.context;
        const numUniforms = gl.getProgramParameter(this.programId, gl.ACTIVE_UNIFORMS);
        for (let i = 0; i < numUniforms; i++) {
            const info = gl.getActiveUniform(this.programId, i);
            if (info === null) {
                throw new Error(`Couldn't get uniform info`);
            }
            const location = gl.getUniformLocation(this.programId, info.name);
            if (location) {
                this.uniformLocations.set(info.name, { type: info.type, location });
            }
        }
    }
    createVAO(index, positions, uvs) {
        const gl = this.context;
        const ext = gl.getExtension('OES_vertex_array_object');
        if (!ext) {
            throw new Error(`Browser doesn't support VAOs`);
        }
        const vaoId = ext.createVertexArrayOES();
        ext.bindVertexArrayOES(vaoId);
        this.bindIndicesBuffer(index);
        this.bindAttributeBuffer(0, 2, positions);
        this.bindAttributeBuffer(1, 2, uvs);
        gl.enableVertexAttribArray(0);
        gl.enableVertexAttribArray(1);
    }
    bindAttributeBuffer(attributeNumber, size, data) {
        const gl = this.context;
        const id = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, id);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
        gl.vertexAttribPointer(attributeNumber, size, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
    bindIndicesBuffer(data) {
        const gl = this.context;
        const id = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, id);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
const namedFilters = [
    {
        name: 'Grimsby',
        values: new FilterTransform(),
    },
    {
        name: 'Slough',
        values: new FilterTransform(),
    },
    {
        name: 'Burnley',
        values: new FilterTransform(),
    },
    {
        name: 'Carlisle',
        values: new FilterTransform(),
    },
    {
        name: 'Stevenage',
        values: new FilterTransform(),
    },
    {
        name: 'Hull',
        values: new FilterTransform(),
    },
    {
        name: 'Swansea',
        values: new FilterTransform(),
    },
    {
        name: 'Luton',
        values: new FilterTransform(),
    },
    {
        name: 'Glasgow',
        values: new FilterTransform(),
    },
    {
        name: 'Dull',
        values: new FilterTransform(),
    },
];

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class EditView extends View {
    constructor() {
        super(document.getElementById('edit-view'));
        this.destElement = document.getElementById('edit-dest');
        this.closeButton = document.getElementById('edit-view-close');
        this.acceptButton = document.getElementById('edit-view-accept');
        this.filterSectionButton = document.getElementById('edit-select-filters');
        this.tuneSectionButton = document.getElementById('edit-select-tuning');
        this.filterSection = document.getElementById('edit-filter');
        this.tuneSection = document.getElementById('edit-tune');
        this.closeButton.addEventListener('click', () => this.closeClick());
        this.acceptButton.addEventListener('click', () => this.acceptClick());
        this.filterSectionButton.addEventListener('click', () => this.toggleSection());
        this.tuneSectionButton.addEventListener('click', () => this.toggleSection());
        this.transform = new FilterTransform();
        this.sliders = new Map();
        const sliderElements = this.viewElement.getElementsByTagName('input');
        for (const slider of Array.from(sliderElements)) {
            this.sliders.set(slider.id, slider);
            slider.addEventListener('input', () => {
                this.transform[slider.id] = Number(slider.value) / 50;
                if (!this.animationFrame) {
                    this.animationFrame = requestAnimationFrame(() => this.draw());
                }
            });
        }
        for (const filter of namedFilters) {
            filter.values.randomize();
            const button = document.createElement('button');
            button.classList.add('filter-button');
            button.id = `filter-button-${filter.name.toLowerCase()}`;
            button.setAttribute('aria-label', filter.name);
            button.tabIndex = 0;
            button.addEventListener('click', () => this.filterButtonClick(filter));
            const canvas = document.createElement('canvas');
            canvas.classList.add('filter-thumbnail');
            button.appendChild(canvas);
            this.filterSection.appendChild(button);
        }
        this.effectButtons = new Set(this.viewElement.querySelectorAll("button.effect-button"));
        for (const effectButton of this.effectButtons) {
            effectButton.addEventListener('click', () => this.effectButtonClick(effectButton));
        }
        this.imageShader = new ImageShader();
        this.imageShader.setFragmentShader(fragmentShader);
        this.sourceElement = null;
        this.sourceWidth = 0;
        this.sourceHeight = 0;
        this.destElement.appendChild(this.imageShader.canvas);
        this.currentPanel = null;
        this.currentRecord = null;
    }
    show() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.getState();
            this.setTransform(state.transform || new FilterTransform());
            if (!state.id) {
                // TODO: Better handling of errors?
                throw new Error(`Couldn't get id of image`);
            }
            const record = yield db.retrieve(state.id);
            this.currentRecord = record;
            this.setTransform(record.transform || new FilterTransform());
            const buffer = record.original;
            const type = constants.IMAGE_TYPE;
            const blob = new Blob([buffer], { type });
            const source = document.createElement('img');
            this.sourceElement = source;
            source.onload = () => {
                URL.revokeObjectURL(source.src);
                this.imageShader.setImage(source);
                this.sourceWidth = source.naturalWidth;
                this.sourceHeight = source.naturalHeight;
                this.animationFrame = requestAnimationFrame(() => this.draw());
                this.renderThumbnails();
            };
            source.src = URL.createObjectURL(blob);
            _super("show").call(this);
        });
    }
    hide() {
        cancelAnimationFrame(this.animationFrame);
        this.sourceElement = null;
        this.animationFrame = 0;
        this.currentRecord = null;
        if (this.currentPanel) {
            this.currentPanel.classList.add('hidden');
        }
        super.hide();
    }
    getState() {
        const state = super.getState();
        state.transform = state.transform || new FilterTransform();
        return state;
    }
    setState(state) {
        if (state.transform) {
            this.setTransform(state.transform);
        }
        super.setState(state);
    }
    renderThumbnails() {
        if (!this.sourceElement) {
            return;
        }
        const aspectRatio = this.sourceWidth / this.sourceHeight;
        const thumbnail = document.createElement('canvas');
        thumbnail.height = 100 * devicePixelRatio;
        thumbnail.width = thumbnail.height * aspectRatio;
        thumbnail.getContext('2d').drawImage(this.sourceElement, 0, 0, thumbnail.width, thumbnail.height);
        const thumbShader = new ImageShader();
        thumbShader.setFragmentShader(fragmentShader);
        thumbShader.setImage(thumbnail);
        const relativeSize = thumbnail.height / this.sourceHeight;
        for (const filter of namedFilters) {
            const output = document.querySelector(`#filter-button-${filter.name.toLowerCase()} .filter-thumbnail`);
            if (!output) {
                console.error(`No output thumbnail for filter ${filter.name}`);
            }
            else {
                setTimeout(() => {
                    output.width = thumbnail.width;
                    output.height = thumbnail.height;
                    const context = output.getContext('2d');
                    thumbShader.setUniform('sourceSize', new Float32Array([1 / thumbnail.width, 1 / thumbnail.height]));
                    const transform = filter.values;
                    // Reduce the blur value relative to the size of the thumbnail
                    thumbShader.setUniform('blur', relativeSize * transform.blur);
                    thumbShader.setUniform('brightness', transform.brightness);
                    thumbShader.setUniform('contrast', transform.contrast);
                    thumbShader.setUniform('grey', transform.grey);
                    thumbShader.setUniform('saturation', transform.saturation);
                    thumbShader.setUniform('sharpen', transform.sharpen);
                    thumbShader.setUniform('vignette', transform.vignette);
                    thumbShader.setUniform('warmth', transform.warmth);
                    thumbShader.render();
                    context.drawImage(thumbShader.canvas, 0, 0, thumbShader.canvas.width, thumbShader.canvas.height, 0, 0, output.width, output.height);
                }, 0);
            }
        }
    }
    setTransform(transform) {
        if (transform instanceof FilterTransform) {
            this.transform = transform;
        }
        else {
            for (const [name] of this.transform) {
                if (transform[name]) {
                    this.transform[name] = transform[name];
                }
            }
        }
        for (const [id, slider] of this.sliders) {
            slider.value = String(this.transform[id] * 50);
        }
    }
    draw() {
        const canvas = this.imageShader.canvas;
        canvas.width = this.sourceWidth;
        canvas.height = this.sourceHeight;
        this.imageShader.setUniform('sourceSize', new Float32Array([1 / canvas.width, 1 / canvas.height]));
        for (const [name, value] of this.transform) {
            this.imageShader.setUniform(name, value);
        }
        this.animationFrame = 0;
        this.imageShader.render();
    }
    filterButtonClick(filter) {
        this.setTransform(filter.values);
        if (!this.animationFrame) {
            this.animationFrame = requestAnimationFrame(() => this.draw());
        }
    }
    effectButtonClick(button) {
        const panel = this.viewElement.querySelector(`#${button.id}-panel`);
        if (this.currentPanel) {
            this.currentPanel.classList.add('hidden');
            if (this.currentPanel !== panel) {
                this.currentPanel = panel;
                panel.classList.remove('hidden');
            }
            else {
                this.currentPanel = null;
            }
        }
        else {
            this.currentPanel = panel;
            panel.classList.remove('hidden');
        }
    }
    toggleSection() {
        this.filterSection.classList.toggle('selected');
        this.tuneSection.classList.toggle('selected');
        this.filterSectionButton.classList.toggle('selected');
        this.tuneSectionButton.classList.toggle('selected');
        if (this.currentPanel) {
            this.currentPanel.classList.add('hidden');
            this.currentPanel = null;
        }
    }
    dataUrlToArrayBuffer(dataURI) {
        const byteString = atob(dataURI.split(',')[1]);
        const ia = new Uint8Array(byteString.length);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        return ia.buffer;
    }
    canvasToArrayBuffer(canvas) {
        return __awaiter(this, void 0, void 0, function* () {
            if (canvas.toBlob) {
                const blob = yield canvasToBlob(canvas, constants.IMAGE_TYPE);
                const buffer = yield blobToArrayBuffer(blob);
                return buffer;
            }
            else {
                const dataURL = canvas.toDataURL(constants.IMAGE_TYPE);
                const buffer = this.dataUrlToArrayBuffer(dataURL);
                return buffer;
            }
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            this.draw();
            const buffer = yield this.canvasToArrayBuffer(this.imageShader.canvas);
            if (this.currentRecord) {
                this.currentRecord.edited = buffer;
                this.currentRecord.transform = this.transform;
                db.store(this.currentRecord);
            }
        });
    }
    closeClick() {
        router.visit(`/browse`);
    }
    acceptClick() {
        this.save().then(() => {
            router.visit(`/browse`);
        });
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class UploadView extends View {
    constructor() {
        super(document.getElementById('upload-view'));
        this.uploadInput = document.getElementById('upload-file-input');
        this.uploadButton = document.getElementById('upload-button');
        this.uploadDropTarget = document.getElementById('upload-drop-target');
        this.closeButton = document.getElementById('upload-view-close');
        this.uploadInput.addEventListener('change', () => this.inputChange());
        this.uploadButton.addEventListener('click', () => this.triggerUpload());
        this.uploadDropTarget.addEventListener('drop', (e) => this.dropHandler(e));
        this.uploadDropTarget.addEventListener('dragover', (e) => this.dragOverHandler(e));
        this.closeButton.addEventListener('click', () => this.close());
    }
    inputChange() {
        this.ingest(this.uploadInput.files);
    }
    triggerUpload() {
        this.uploadInput.click();
    }
    dragOverHandler(e) {
        e.stopPropagation();
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
    }
    dropHandler(e) {
        e.stopPropagation();
        e.preventDefault();
        this.ingest(e.dataTransfer.files);
    }
    ingest(files) {
        if (files.length === 0) {
            return;
        }
        const file = files[0];
        const reader = new FileReader();
        reader.addEventListener('loadend', (e) => __awaiter(this, void 0, void 0, function* () {
            const buffer = reader.result;
            const record = new ImageRecord(buffer);
            const id = yield db.store(record);
            router.visit(`/edit/${id}`);
        }));
        reader.readAsArrayBuffer(file);
    }
    close() {
        router.visit(`/browse`);
    }
}

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
class Router {
    constructor() {
        window.addEventListener('popstate', (e) => this.changeHandler(e.state));
        this.browseView = new BrowseView();
        this.captureView = new CaptureView();
        this.editView = new EditView();
        this.uploadView = new UploadView();
    }
    changeHandler(state) {
        // TODO: Not sure that I should take the state here
        // Ignore any changes in the hash.
        if (window.location.pathname === this.currentLocation) {
            return;
        }
        this.currentLocation = window.location.pathname;
        const parts = this.currentLocation.split('/');
        if (this.currentView) {
            this.currentView.hide();
        }
        if (!state) {
            state = new ViewState();
        }
        let newView = null;
        switch (parts[1]) {
            case 'capture':
                newView = this.captureView;
                break;
            case '': // Entry point
            case 'browse':
                newView = this.browseView;
                break;
            case 'edit':
                newView = this.editView;
                state.id = Number(parts[2]);
                break;
            case 'upload':
                newView = this.uploadView;
                break;
            default:
                // TODO: Proper 404
                console.log('404');
        }
        if (newView) {
            this.switch(newView, state);
        }
        else {
            // TODO: Something better?
            console.log('Oh no, no view found!');
        }
    }
    switch(newView, state) {
        if (this.currentView) {
            this.currentView.hide();
        }
        newView.setState(state);
        newView.show();
        this.currentView = newView;
    }
    visit(url) {
        if (window.location.href === url) {
            return;
        }
        let state;
        if (this.currentView) {
            state = this.currentView.getState();
        }
        window.history.replaceState(state, '', window.location.href);
        window.history.pushState(null, '', url);
        this.changeHandler();
    }
    click(event) {
        const anchor = event.target;
        if (event.metaKey || event.ctrlKey || event.button !== 0) {
            return;
        }
        event.preventDefault();
        this.visit(anchor.href);
    }
}
var router = new Router();
//# sourceMappingURL=router.js.map

/*
  Copyright 2017 Google Inc. All Rights Reserved.
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
}
router.changeHandler();
//# sourceMappingURL=index.js.map
//# sourceMappingURL=app.min.js.map
